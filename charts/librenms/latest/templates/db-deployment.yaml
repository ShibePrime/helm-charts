
# deploy the MySQL server container

apiVersion: extensions/v1beta1
# https://kubernetes.io/docs/concepts/workloads/controllers/deployment/
kind: Deployment
metadata:
  name: db
spec:
  # number of MySQL pods (replicas) to run
  replicas: 1
  # The number of old deployments you want to keep around
  revisionHistoryLimit: 5
  # make replicas of kubernetes objects with the label app: mysql
  selector:
    matchLabels:
      app: db
  # the pod template describes what type of pod to create
  # when the defined number of replicas are not up
  # in this case, the pod that will be created is the one labeled app: mysql
  template:
    metadata:
      labels:
        # this label is referenced by the selector for the Deployment, which creates pods
        # and by the selector for the Service, which exposes the pod to the cluster
        app: db
    # details of what container(s) will actually be run in this pod
    spec:
      containers:
      - args:
        - mysqld
        - --sql-mode=
        - --innodb-file-per-table=1
        - --lower-case-table-names=0
        image: mariadb:10.2
        name: db
        resources: {}
        volumeMounts:
        - mountPath: /var/lib/mysql
          name: db-claim0
        env:
          - name: MYSQL_ROOT_PASSWORD
            value: librenms
          - name: MYSQL_DATABASE
            value: librenms
          - name: MYSQL_PASSWORD
            value: librenms
          - name: MYSQL_USER
            value: librenms
          - name: MYSQL_DATABASE
            value: db
        # https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/
        livenessProbe:
          tcpSocket:
            port: 3306
        # https://kubernetes.io/docs/concepts/services-networking/connect-applications-service/#exposing-pods-to-the-cluster
        ports:
        # make our mysql pod available within the cluster on port 3306
        - containerPort: 3306
        # attach our persistent disk

      # our spec requires a volume
      volumes:
      # the name assigned here is referenced by the container in volumeMounts: name
      - name: db-claim0
        persistentVolumeClaim:
          # refers to the PersistentVolumeClaim named database
          # this expects a PersistentVolumeClaim volume to exist already
          # with correct permissions for this cluster
          claimName: db-claim0

---
# expose a pod on mysql.default.svc.cluster.local to the rest of the cluster

apiVersion: v1
# https://kubernetes.io/docs/concepts/services-networking/service/
kind: Service
metadata:
  # the name mysql here means you can reference the pod
  # using the host mysql.default.svc.cluster.local from within the cluster
  name: db
spec:
  # allows us to set our own internal IP to reference this pod
  # in this case we care about the port
  # https://kubernetes.io/docs/concepts/services-networking/service/#choosing-your-own-ip-address
  type: ClusterIP
  ports:
  # make the service available on this port within the cluster
  - port: 3306
    protocol: TCP
  # apply this service to the pod with the label app: mysql
  selector:
    app: db
